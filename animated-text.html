<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>Rinksprite Animated Text</title>
<!-- animated-text.html (part of Rinksprite) -->
<!--

The copyright and license information below applies to this file as an
independent work. Other files commonly used or bundled with this one
may have different authors and different posted licenses.

-->
<!--

Copyright (c) 2014, Ross Angle
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<meta name="viewport"
    content="initial-scale = 1.0, maximum-scale = 1.0" />
<style type="text/css">
#sample-rectangle {
    position: relative;
    width: 204px;
    height: 246px;
    background: #006600;
}
#sample-rectangle-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
}
#text-to-animate-wrapper {
    position: relative;
    font-family: sans-serif;
    text-shadow: 2px 1px 2px rgba( 0, 0, 0, 0.3 );
}
</style>
<script type="text/javascript" src="lib/lathe.js"></script>
<script type="text/javascript">"use strict";

var _ = rocketnia.lathe;

(function () {


function setTranslation( elem, x, y ) {
    // NOTE: We leave out any whitespace before ')' so that IE11 can
    // parse the translation.
    elem.style.WebkitTransform =
    elem.style.transform =
        "translate( " + x + "px, " + y + "px)";
}
function clearTransformation( elem ) {
    elem.style.WebkitTransform =
    elem.style.transform =
        "";
}


function animateForever( onFrame, onCancel ) {
    
    var startMillis = new Date().getTime();
    
    var canceled = false;
    
    function cancel() {
        if ( canceled )
            return;
        canceled = true;
        onCancel();
    }
    
    animate();
    function animate() {
        requestAnimationFrame( function () {
            var nowMillis = new Date().getTime();
            
            if ( canceled )
                return;
            
            onFrame( nowMillis - startMillis );
            
            animate();
        } );
    }
    
    var result = {};
    result.cancel = function () {
        cancel();
    };
    return result;
}

function animateText( elems, charactersPerSecond ) {
    if ( elems.textToAnimate.childNodes.length !== 1 )
        throw new Error();
    var textNodeToAnimate = elems.textToAnimate.childNodes.item( 0 );
    if ( textNodeToAnimate.nodeType !== document.TEXT_NODE )
        throw new Error();
    
    elems.hideParaEnd.style.backgroundColor = "white";
    elems.hideParaEnd.style.position = "absolute";
    elems.hideLineEnd.style.backgroundColor = "white";
    elems.hideLineEnd.style.position = "absolute";
    
    var charactersPerSecond = 100;
    var textIndex = 0;
    
    var result = animateForever( function ( elapsedMillis ) {
        var charactersToConsume =
            Math.min( textNodeToAnimate.data.length,
                ~~(elapsedMillis * charactersPerSecond / 1000) );
        var inWhitespace = true;
        var beenOutOfWhitespace = false;
        var n = textNodeToAnimate.data.length;
        for ( var i = 0; i < n; i++ ) {
            if ( charactersToConsume === 0 )
                break;
            
            if ( /^[ \t\r\n]$/.test(
                textNodeToAnimate.data.charAt( i ) ) ) {
                
                inWhitespace = true;
            } else {
                if ( inWhitespace && beenOutOfWhitespace ) {
                    charactersToConsume--;
                    if ( charactersToConsume === 0 ) {
                        i--;
                        break;
                    }
                }
                charactersToConsume--;
                inWhitespace = false;
                beenOutOfWhitespace = true;
            }
        }
        
        var hideRange = document.createRange();
        hideRange.setStart( textNodeToAnimate, i );
        hideRange.setEndAfter( elems.textToAnimateWrapper );
        var hideRects = hideRange.getClientRects();
        if ( hideRects.length === 0 ) {
            // NOTE: Chrome doesn't get here, but other browsers do.
            elems.hideParaEnd.style.display = "none";
            elems.hideLineEnd.style.display = "none";
            return void result.cancel();
        }
        var hideLineRect = hideRects.item( 0 );
        
        var wrapperRect = elems.textToAnimate.getBoundingClientRect();
        
        elems.hideParaEnd.style.top =
            (hideLineRect.bottom - wrapperRect.top) + "px";
        elems.hideParaEnd.style.left = "0px";
        elems.hideParaEnd.style.height =
            (wrapperRect.bottom - hideLineRect.bottom) + "px";
        elems.hideParaEnd.style.width = wrapperRect.width + "px";
        
        elems.hideLineEnd.style.top =
            (hideLineRect.top - wrapperRect.top) + "px";
        elems.hideLineEnd.style.left =
            (hideLineRect.left - wrapperRect.left) + "px";
        elems.hideLineEnd.style.height =
            (wrapperRect.bottom - hideLineRect.top) + "px";
        elems.hideLineEnd.style.width =
            (wrapperRect.right - hideLineRect.left) + "px";
        
        if ( i === textNodeToAnimate.data.length )
            return void result.cancel();
    }, function () {  // onCancel
        // TODO: Implement this.
    } );
    return result;
}

function animateShock(
    elems, totalMillis, updateMillis, squareRadiusPx ) {
    
    // NOTE: This may clobber the CSS `transform` properties of
    // `elems.elem`.
    
    var nextChangeMillis = 0;
    var result = animateForever( function ( elapsedMillis ) {
        if ( totalMillis <= elapsedMillis )
            return void result.cancel();
        
        if ( nextChangeMillis <= elapsedMillis ) {
            var randCoord = function () {
                return Math.random() * squareRadiusPx * 2 -
                    squareRadiusPx;
            };
            setTranslation( elems.elem, randCoord(), randCoord() );
            nextChangeMillis += updateMillis;
        }
    }, function () {  // onCancel
        clearTransformation( elems.elem );
    } );
    return result;
}

function animateFlash( elems, totalMillis, glowFactor ) {
    var oldBackground = elems.cover.style.background;
    var oldBoxShadow = elems.cover.style.boxShadow;
    var result = animateForever( function ( elapsedMillis ) {
        if ( totalMillis <= elapsedMillis )
            return void result.cancel();
        
        var diffMillis = 1 - 2 * elapsedMillis / totalMillis;
        var flashWhite = "rgba( 255, 255, 255, " +
            (1 - diffMillis * diffMillis) * 0.5 + " )";
        var bounds = elems.container.getBoundingClientRect();
        var shadowRadiusPx =
            Math.sqrt( bounds.width * bounds.height ) * glowFactor;
        elems.cover.style.background = flashWhite;
        elems.cover.style.boxShadow =
            "" + flashWhite + " 0 0 " +
            shadowRadiusPx * 2 + "px " + shadowRadiusPx + "px";
    }, function () {  // onCancel
        elems.cover.style.background = oldBackground;
        elems.cover.style.boxShadow = oldBoxShadow;
    } );
    return result;
}

function easeLinear( t ) {
    return t;
}
function easeInBackWithCoef( coef ) {
    return function ( t ) {
        return t * t * ((coef + 1) * t - coef);
    };
}
function easeInBackWithOvershoot( d ) {
    
    // NOTE: The "d" is for "overshoot distance," and it's measured
    // such that adding it to 1 gives the complete length of the
    // easing function's range interval.
    
    // NOTE: The "c" below is for "overshoot coefficient."
    // Robert Penner's easing code calls it "s".
    
    // The easing function is this function of t for some c:
    //
    //   (c + 1) * t * t * t - c * t * t
    //
    // We take the derivative with respect to t:
    //
    //   3 * (c + 1) * t * t - 2 * c * t
    //
    // Then we use the quadratic formula to find the zeros.
    //
    //   0
    //   -2 / 3 * c / (c + 1)
    //
    // We plug these values of t into the easing function to get the
    // local maximum and local minimum at the cubic's two humps:
    //
    //   0
    //   -20 / 27 * c * c * c / (c + 1) / (c + 1)
    //
    // What we actually care about is the negation of the local
    // minimum. This negation is the value we would like to fix as d.
    //
    //   d = 20 / 27 * c * c * c / (c + 1) / (c + 1)
    //
    // What remains is to solve this for c, which we can do by framing
    // this as a polynomial (as long as c is not -1). We ask
    // Wolfram Alpha
    // "Solve (0 = 20 / 27 * c^3 - d * c^2 + 2 * d * c - d) for c":
    
    // TODO: See if we need to handle the case where (5 < d), since
    // right now Math.sqrt() won't be very helpful in that case.
    
    if ( 5 < d )
        throw new Error();
    
    var d2 = d * d;
    var d3 = d2 * d;
    var cubeRoot = Math.pow(
        27 * d3 - 180 * d2 + 200 * d +
            40 * Math.sqrt( 5 ) * Math.sqrt( 5 * d2 - d3 ),
        1 / 3 );
    var c =
        3 / 20 * cubeRoot - (3240 * d - 729 * d2) / (540 * cubeRoot) +
            9 * d / 20;
    
    return easeInBackWithCoef( c );
}
function easeOut( easeIn ) {
    return function ( t ) {
        return 1 - easeIn( 1 - t );
    };
}
function easeInPow( pow ) {
    return function ( t ) {
        return Math.pow( t, pow );
    };
}

var easeInBack = easeInBackWithCoef( 1.7 );
var easeOutBack = easeOut( easeInBack );
// TODO: Oops, easeInBackWithOvershoot() actually doesn't work very
// well. Figure out what's wrong with it.
//var easeOutBack = easeOut( easeInBackWithOvershoot( 1 / 10 ) );

var easeInLinear = easeInPow( 1 );
var easeOutLinear = easeOut( easeInLinear );
var easeInQuad = easeInPow( 2 );
var easeOutQuad = easeOut( easeInQuad );


function animateEasing( totalMillis, onFrame, onCancel ) {
    var result = animateForever( function ( elapsedMillis ) {
        if ( totalMillis <= elapsedMillis )
            return void result.cancel();
        
        onFrame( elapsedMillis / totalMillis );
    }, onCancel );
    return result;
}


function combineHotspotAnimations( anims ) {
    
    // Sort the animations by the durations to their hotspots, with
    // the longest durations first.
    anims = anims.slice().sort( function ( a, b ) {
        return b.hotspot - a.hotspot;
    } );
    
    var furthestAwayHotspot =
        anims.length === 0 ? 0 : anims[ 0 ].hotspot;
    
    var result = {};
    result.hotspot = furthestAwayHotspot;
    result.play = function () {
        var remaining = anims.slice();
        var spawned = [];
        
        var spawner = animateForever( function ( elapsedMillis ) {
            if ( remaining.length === 0 )
                spawner.cancel();
            else if ( furthestAwayHotspot - remaining[ 0 ].hotspot <=
                elapsedMillis )
                spawned.push( remaining.shift().play() );
        }, function () {  // onCancel
            // Do nothing.
        } );
        
        var result = {};
        result.cancel = function () {
            spawner.cancel();
            _.arrEach( spawned, function ( it ) {
                it.cancel();
            } );
        };
        return result;
    };
    return result;
}


addEventListener( "load", function () {
    
    var textToAnimateWrapper =
        document.getElementById( "text-to-animate-wrapper" );
    var hideParaEnd = document.getElementById( "hide-para-end" );
    var hideLineEnd = document.getElementById( "hide-line-end" );
    var textToAnimate = document.getElementById( "text-to-animate" );
    animateText( {
        textToAnimateWrapper: textToAnimateWrapper,
        hideParaEnd: hideParaEnd,
        hideLineEnd: hideLineEnd,
        textToAnimate: textToAnimate
    }, 100 );
    
    var sampleRectangle =
        document.getElementById( "sample-rectangle" );
    var sampleRectangleCanvas =
        document.getElementById( "sample-rectangle-canvas" );
    
    var currentAnimation = {};
    currentAnimation.cancel = function () {
        // Do nothing.
    };
    
    var buttons = document.getElementById( "buttons" );
    function addButton( title, makeAnimation ) {
        var button = document.createElement( "button" );
        button.appendChild( document.createTextNode( title ) );
        button.addEventListener( "click", function () {
            currentAnimation.cancel();
            currentAnimation = makeAnimation();
        }, !"capture" );
        buttons.appendChild( button );
    }
    
    addButton( "Shock", function () {
        return animateShock( {
            elem: sampleRectangle
        }, 400, 100, 40 );
    } );
    
    addButton( "Flash", function () {
        return animateFlash( {
            container: sampleRectangle,
            cover: sampleRectangleCanvas
        }, 100, 0.2 );
    } );
    
    var w = sampleRectangle.getBoundingClientRect().width;
    function animateEnter( totalMillis, ease ) {
        return animateEasing( totalMillis, function ( t ) {
            setTranslation(
                sampleRectangle, -w * ease( 1 - t ), 0 );
        }, function () {
            clearTransformation( sampleRectangle );
        } );
    }
    function animateExit( totalMillis, ease ) {
        return animateEasing( totalMillis, function ( t ) {
            setTranslation( sampleRectangle, -w * ease( t ), 0 );
        }, function () {
            clearTransformation( sampleRectangle );
        } );
    }
    function addEnterButton( title, ease ) {
        addButton( title, function () {
            return animateEnter( 400, ease );
        } );
    }
    function addExitButton( title, ease ) {
        addButton( title, function () {
            return animateExit( 400, ease );
        } );
    }
    
    addEnterButton( "Enter quad", easeInQuad );
    addEnterButton( "Enter back", easeInBack );
    addExitButton( "Exit quad", easeInQuad );
    addExitButton( "Exit back", easeInBack );
    
    addButton( "Enter and shock", function () {
        return combineHotspotAnimations( [ {
            hotspot: 400,
            play: function () {
                return animateEnter( 400, easeInLinear );
            }
        }, {
            hotspot: 0,
            play: function () {
                return animateShock( {
                    elem: sampleRectangle
                }, 400, 100, 40 );
            }
        } ] ).play();
    } );
}, !"capture" );

})();

</script>
</head>
<body>
<div id="sample-rectangle"
    ><canvas id="sample-rectangle-canvas" width="1" height="1"
        ></canvas
    ><img src="lib/elisa-standalone.png" width="204" height="246"
        /></div>
<div id="text-to-animate-wrapper"
    ><div id="hide-para-end"></div
    ><div id="hide-line-end"></div
    ><div id="text-to-animate"
        >This is some animating text. This is some animating text.
        This is some animating text. This is some animating text. This
        is some animating text. This is some animating text. This is
        some animating text. This is some animating text.</div></div>
<div id="buttons"></div>
</body>
</html>
