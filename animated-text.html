<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<title>Rinksprite Animated Text</title>
<!-- animated-text.html (part of Rinksprite) -->
<!--

The copyright and license information below applies to this file as an
independent work. Other files commonly used or bundled with this one
may have different authors and different posted licenses.

-->
<!--

Copyright (c) 2014, 2022 Rocketnia
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<meta name="viewport"
    content="initial-scale = 1.0, maximum-scale = 1.0" />
<style type="text/css">

.stage {
    position: relative;
    overflow: hidden;
    height: 280px;
    width: 500px;
    margin: 6px;
    border: 2px solid black;
    font-family: sans-serif;
    text-shadow: 2px 1px 2px rgba(0, 0, 0, 0.3);
    background: linear-gradient(to bottom,
        rgb(24, 128, 196) 0%,
        rgb(99, 170, 217) 20%,
        rgb(99, 170, 217) 60%,
        rgb(0, 0, 0) 100%);
    cursor: default;
}
.line {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}
.speaker {
    position: absolute;
    bottom: 0;
}
.stylish-text-wrapper {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 75px;
    background: black;
}
.stylish-text-wrapper > div {
    position: absolute;
    top: 2px;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 10px 10px 0 0;
    background: linear-gradient(to bottom,
        rgb(255, 84, 69) 50%,
        rgb(146, 50, 62) 100%);
}
.stylish-text-wrapper > div > div {
    position: absolute;
    top: 5px;
    left: 5px;
    right: 5px;
    bottom: 0;
    border-radius: 5px 5px 0 0;
    background: white;
}
.stylish-text-wrapper > div > div:after {
    content: "";
    position: absolute;
    bottom: 4px;
    right: 10px;
    border-top: 9px solid black;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
}
.stylish-text-wrapper > div > div > div {
    position: absolute;
    top: 5px;
    left: 5px;
    right: 25px;
    bottom: 0;
    overflow: auto;
}

#debug-area {
    overflow: hidden;
    margin: 6px;
    border: 2px solid black;
}
#sample-rectangle {
    position: relative;
    width: 204px;
    height: 246px;
    background: rgb(99, 170, 217);
}
#sample-rectangle img {
    image-rendering: pixelated;
}
#sample-rectangle-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
}
#text-to-animate {
    position: relative;
    font-family: sans-serif;
    text-shadow: 2px 1px 2px rgba(0, 0, 0, 0.3);
}
#buttons {
    margin: 10px 4px;
}

/*
#sample-rectangle, #text-to-animate, #buttons {
    display: none;
}
*/

</style>
<script type="text/javascript" src="lib/lathe.js"></script>
<script type="text/javascript" src="sample-conversation.js"></script>
<script type="text/javascript">"use strict";

var _ = rocketnia.lathe;

(function () {


function setStyles( elem, styleObj ) {
    return _.objAcc( function ( y ) {
        _.objOwnEach( styleObj, function ( k, v ) {
            y( k, elem.style[ k ] );
        } );
        _.objOwnEach( styleObj, function ( k, v ) {
            elem.style[ k ] = v;
        } );
    } );
}

function setTransform( elem, transform ) {
    return setStyles( elem, {
        WebkitTransform: transform,
        transform: transform
    } );
}

function setTranslation( elem, x, y ) {
    // NOTE: We leave out any whitespace before ')' so that IE11 can
    // parse the translation.
    return setTransform( elem,
        "translate( " + x + "px, " + y + "px)" );
}


function animateFor( totalMillis, onFrame, onCancel ) {
    
    var startMillis = new Date().getTime();
    
    var canceled = false;
    
    function cancel() {
        if ( canceled )
            return;
        canceled = true;
        onCancel();
    }
    
    animate();
    function animate() {
        requestAnimationFrame( function () {
            var nowMillis = new Date().getTime();
            
            if ( canceled )
                return;
            
            var elapsedMillis = nowMillis - startMillis;
            
            if ( totalMillis <= elapsedMillis )
                return void cancel();
            
            onFrame( elapsedMillis );
            
            animate();
        } );
    }
    
    var result = {};
    result.cancel = function () {
        cancel();
    };
    return result;
}

function animateText( elems, charactersPerSecond ) {
    function getTextNodesFromChildNodes( nodes ) {
        var textNodesToAnimate = [];
        var stack = [ { nodes: nodes, index: 0 } ];
        while ( stack.length !== 0 ) {
            var nodesToAdd = stack.pop();
            if ( !(nodesToAdd.index < nodesToAdd.nodes.length) )
                continue;
            var node = nodesToAdd.nodes.item( nodesToAdd.index );
            stack.push( {
                nodes: nodesToAdd.nodes,
                index: nodesToAdd.index + 1
            } );
            if ( node.nodeType === document.TEXT_NODE ) {
                textNodesToAnimate.push( node );
            } else if ( node.nodeType === document.ELEMENT_NODE ) {
                stack.push( { nodes: node.childNodes, index: 0 } );
            } else if ( node.nodeType === document.COMMENT_NODE ) {
                // Do nothing.
            } else {
                throw new Error(
                    "Element type not supported (yet): " +
                    node.nodeType );
            }
        }
        return textNodesToAnimate;
    }
    var textNodesToAnimate = getTextNodesFromChildNodes(
        elems.textToAnimate.childNodes );
    var currentTextNodeIndex = 0;
    var currentTextNodeCharacterIndex = 0;
    
    var origParaEndStyles = setStyles( elems.hideParaEnd, {
        backgroundColor: "white",
        position: "absolute",
        top: "",
        left: "",
        height: "",
        width: ""
    } );
    var origLineEndStyles = setStyles( elems.hideLineEnd, {
        backgroundColor: "white",
        position: "absolute",
        top: "",
        left: "",
        height: "",
        width: ""
    } );
    
    var previousElapsedMillis = 0;
    var previousRemainingCharactersToConsume = 0;
    var result = animateFor( 1 / 0, function ( elapsedMillis ) {
        var deltaMillis = elapsedMillis - previousElapsedMillis;
        previousElapsedMillis = elapsedMillis;
        var fractionalCharactersToConsume =
            previousRemainingCharactersToConsume +
            deltaMillis * charactersPerSecond / 1000;
        var charactersToConsume = ~~fractionalCharactersToConsume;
        previousRemainingCharactersToConsume =
            fractionalCharactersToConsume - charactersToConsume;
        
        function isWhitespace( ch ) {
            return /^[ \t\r\n]$/.test( ch );
        }
        while ( (true
            && currentTextNodeIndex < textNodesToAnimate.length
            && 0 < charactersToConsume
        ) ) {
            var data =
                textNodesToAnimate[ currentTextNodeIndex ].data;
            var skippedWhitespace = false;
            while ( (true
                && currentTextNodeCharacterIndex < data.length
                && isWhitespace(
                    data.charAt( currentTextNodeCharacterIndex ) )
            ) ) {
                skippedWhitespace = true;
                currentTextNodeCharacterIndex++;
            }
            if ( skippedWhitespace ) {
                charactersToConsume--;
            }
            if ( data.length <= currentTextNodeCharacterIndex ) {
                currentTextNodeIndex++;
                currentTextNodeCharacterIndex = 0;
            } else if ( !skippedWhitespace ) {
                // TODO: Handle UTF-16 surrogate code points and
                // extended grapheme clusters.
                currentTextNodeCharacterIndex++;
                charactersToConsume--;
            }
        }
        
        if ( textNodesToAnimate.length <= currentTextNodeIndex )
            return void result.cancel();
        
        var hideRange = document.createRange();
        hideRange.setStart(
            textNodesToAnimate[ currentTextNodeIndex ],
            currentTextNodeCharacterIndex );
        hideRange.setEndAfter( elems.textToAnimateWrapper );
        var hideRects = hideRange.getClientRects();
        if ( hideRects.length === 0 ) {
            // NOTE: Chrome doesn't get here, but other browsers do.
            return void result.cancel();
        }
        var hideLineRect = hideRects.item( 0 );
        
        var wrapperRect = elems.textToAnimate.getBoundingClientRect();
        
        setStyles( elems.hideParaEnd, {
            top: (hideLineRect.bottom - wrapperRect.top) + "px",
            left: "0px",
            height: (wrapperRect.bottom - hideLineRect.bottom) + "px",
            width: wrapperRect.width + "px"
        } );
        setStyles( elems.hideLineEnd, {
            top: (hideLineRect.top - wrapperRect.top) + "px",
            left: (hideLineRect.left - wrapperRect.left) + "px",
            height: (wrapperRect.bottom - hideLineRect.top) + "px",
            width: (wrapperRect.right - hideLineRect.left) + "px"
        } );
    }, function () {  // onCancel
        setStyles( elems.hideParaEnd, origParaEndStyles );
        setStyles( elems.hideLineEnd, origLineEndStyles );
    } );
    return result;
}

function animateShock(
    elems, totalMillis, updateMillis, squareRadiusPx ) {
    
    var oldStyles = setTransform( elems.elem, "" );
    var nextChangeMillis = 0;
    return animateFor( totalMillis, function ( elapsedMillis ) {
        if ( nextChangeMillis <= elapsedMillis ) {
            var randCoord = function () {
                return Math.random() * squareRadiusPx * 2 -
                    squareRadiusPx;
            };
            setTranslation( elems.elem, randCoord(), randCoord() );
            nextChangeMillis += updateMillis;
        }
    }, function () {  // onCancel
        setStyles( elems.elem, oldStyles );
    } );
}

function animateFlash( elems, totalMillis, glowFactor ) {
    var oldStyles = setStyles( elems.cover, {
        background: "",
        boxShadow: ""
    } );
    return animateFor( totalMillis, function ( elapsedMillis ) {
        var diffMillis = 1 - 2 * elapsedMillis / totalMillis;
        var flashWhite = "rgba( 255, 255, 255, " +
            (1 - diffMillis * diffMillis) * 0.5 + " )";
        var bounds = elems.container.getBoundingClientRect();
        var shadowRadiusPx =
            Math.sqrt( bounds.width * bounds.height ) * glowFactor;
        setStyles( elems.cover, {
            background: flashWhite,
            boxShadow:
                "" + flashWhite + " 0 0 " +
                shadowRadiusPx * 2 + "px " + shadowRadiusPx + "px"
        } );
    }, function () {  // onCancel
        setStyles( elems.cover, oldStyles );
    } );
}

function easeLinear( t ) {
    return t;
}
function easeInBackWithCoef( coef ) {
    return function ( t ) {
        return t * t * ((coef + 1) * t - coef);
    };
}
function easeInBackWithOvershoot( d ) {
    
    // NOTE: The "d" is for "overshoot distance," and it's measured
    // such that adding it to 1 gives the complete length of the
    // easing function's range interval.
    
    // NOTE: The "c" below is for "overshoot coefficient."
    // Robert Penner's easing code calls it "s".
    
    // The easing function is this function of t for some c:
    //
    //   (c + 1) * t * t * t - c * t * t
    //
    // We take the derivative with respect to t:
    //
    //   3 * (c + 1) * t * t - 2 * c * t
    //
    // Then we use the quadratic formula to find the zeros.
    //
    //   0
    //   2 / 3 * c / (c + 1)
    //
    // We plug these values of t into the easing function to get the
    // local maximum and local minimum at the cubic's two humps:
    //
    //   0
    //   -4 / 27 * c * c * c / (c + 1) / (c + 1)
    //
    // What we actually care about is the negation of the local
    // minimum. This negation is the value we would like to fix as d.
    //
    //   d = 4 / 27 * c * c * c / (c + 1) / (c + 1)
    //
    // What remains is to solve this for c, which we can do by framing
    // this as a polynomial (as long as c is not -1). We ask
    // Wolfram Alpha
    // "Solve (0 = 4 / 27 * c^3 - d * c^2 - 2 * d * c - d) for c":
    
    // TODO: See if we need to handle the case where (d < -1), since
    // right now Math.sqrt() won't be very helpful in that case.
    
    if ( d < -1 )
        throw new Error();
    
    var d2 = d * d;
    var d3 = d2 * d;
    var cubeRoot = Math.pow(
        27 * d3 + 36 * d2 + 8 * Math.sqrt( d3 + d2 ) + 8 * d,
        1 / 3 );
    // When (d = 0), a division step would fail us here, but the
    // limiting behavior indicates the proper choice of coefficient is
    // 0 in this case.
    if ( cubeRoot === 0 )
        return easeInBackWithCoef( 0 );
    var c =
        3 / 4 * (((9 * d2 + 8 * d) / cubeRoot) + cubeRoot + 3 * d);
    
    return easeInBackWithCoef( c );
}
function easeOut( easeIn ) {
    return function ( t ) {
        return 1 - easeIn( 1 - t );
    };
}
function easeInPow( pow ) {
    return function ( t ) {
        return Math.pow( t, pow );
    };
}

// Our original implementation of `easeInBackWithOvershoot` was buggy.
// While it was, we were using `easeInBackWithCoef( 1.7 )` to
// approximate `easeInBackWithOvershoot( 1 / 10 )`. That was close! It
// seems a more accurate approximation would have been
// `easeInBackWithCoef( 1.7015401988668237 )`.
//
//var easeInBack = easeInBackWithCoef( 1.7 );
var easeInBack = easeInBackWithOvershoot( 1 / 10 );
var easeOutBack = easeOut( easeInBack );

var easeInLinear = easeInPow( 1 );
var easeOutLinear = easeOut( easeInLinear );
var easeInQuad = easeInPow( 2 );
var easeOutQuad = easeOut( easeInQuad );


function animateEasing( totalMillis, onFrame, onCancel ) {
    return animateFor( totalMillis, function ( elapsedMillis ) {
        onFrame( elapsedMillis / totalMillis );
    }, onCancel );
}


function combineHotspotAnimations( anims ) {
    
    // Sort the animations by the durations to their hotspots, with
    // the longest durations first.
    anims = anims.slice().sort( function ( a, b ) {
        return b.hotspot - a.hotspot;
    } );
    
    var furthestAwayHotspot =
        anims.length === 0 ? 0 : anims[ 0 ].hotspot;
    
    var result = {};
    result.hotspot = furthestAwayHotspot;
    result.play = function () {
        var canceled = false;
        var remaining = anims.slice();
        var spawned = [];
        
        var spawner = animateFor( 1 / 0, function ( elapsedMillis ) {
            if ( remaining.length === 0 )
                spawner.cancel();
            else if ( furthestAwayHotspot - remaining[ 0 ].hotspot <=
                elapsedMillis )
                spawned.push( remaining.shift().play() );
        }, function () {  // onCancel
            // Do nothing.
        } );
        
        var result = {};
        result.cancel = function () {
            if ( canceled )
                return;
            canceled = true;
            spawner.cancel();
            _.arrEach( spawned, function ( it ) {
                it.cancel();
            } );
            _.arrEach( remaining, function ( it ) {
                it.play().cancel();
            } );
            spawned = null;
            remaining = null;
        };
        return result;
    };
    return result;
}

function animateExclusiveSequence(
    firstDurationMillis, playFirst, playSecond ) {
    
    var canceled = false;
    var animation = playFirst();
    animateFor( firstDurationMillis, function ( elapsedMillis ) {
        // Do nothing.
    }, function () {  // onCancel
        if ( canceled )
            return;
        animation.cancel();
        animation = playSecond();
    } );
    
    var result = {};
    result.cancel = function () {
        canceled = true;
        animation.cancel();
    };
    return result;
}

function animateEnterHorizTemp( totalMillis, elem, w, ease ) {
    var oldStyles = setTransform( elem, "" );
    return animateEasing( totalMillis, function ( t ) {
        setTranslation( elem, -w * ease( 1 - t ), 0 );
    }, function () {
        setStyles( elem, oldStyles );
    } );
}
function animateExitHorizTemp( totalMillis, elem, w, ease ) {
    var oldStyles = setTransform( elem, "" );
    return animateEasing( totalMillis, function ( t ) {
        setTranslation( elem, -w * ease( t ), 0 );
    }, function () {
        setStyles( elem, oldStyles );
    } );
}
function animateEnterHoriz( totalMillis, elem, w, ease ) {
    return animateEasing( totalMillis, function ( t ) {
        setTranslation( elem, -w * ease( 1 - t ), 0 );
    }, function () {
        setTranslation( elem, 0, 0 );
    } );
}
function animateExitHoriz( totalMillis, elem, w, ease ) {
    return animateEasing( totalMillis, function ( t ) {
        setTranslation( elem, -w * ease( t ), 0 );
    }, function () {
        setTranslation( elem, -w, 0 );
    } );
}
function animateEnterVert( totalMillis, elem, h, ease ) {
    return animateEasing( totalMillis, function ( t ) {
        setTranslation( elem, 0, h * ease( 1 - t ) );
    }, function () {
        setTranslation( elem, 0, 0 );
    } );
}
function animateExitVert( totalMillis, elem, h, ease ) {
    return animateEasing( totalMillis, function ( t ) {
        setTranslation( elem, 0, h * ease( t ) );
    }, function () {
        setTranslation( elem, 0, h );
    } );
}

// TODO: Import this from Chopsgen, or rather move this from Chopsgen
// into Lathe or something.
// TODO: See if this is sufficient.
var htmlEscape = function ( content ) {
    return content.
        replace( /&/g, "&amp;" ).  // must come first
        replace( /<(?:)/g, "&lt;" ).
        replace( />/g, "&gt;" ).
        // TODO: See if the following can be removed.
        replace( /\u2013/g, "&ndash;" ).
        replace( /\u2014/g, "&mdash;" ).
        replace( /\u00A9/g, "&copy;" );
};

function compileConversation( lines, getSpeakerInfo ) {
    if ( !(true
        && _.likeArray( lines )
        && _.arrAll( lines, function ( line ) {
            return (true
                && _.likeArray( line )
                && 2 <= line.length
                && _.arrAll( line, function ( x ) {
                    return _.isString( x );
                } )
            );
        } )
    ) )
        throw new Error();
    
    function jsonForScriptTag( jsonObj ) {
        return JSON.stringify( jsonObj ).replace( "<", "\\u003c" );
    }
    
    var processedLines = _.arrMap( lines, function ( line ) {
        var speakerId = line[ 0 ];
        var stageDirections = _.arrCut( line, 1, line.length - 1 );
        var dialogue = line[ line.length - 1 ];
        var mood = null;
        _.arrEach( stageDirections, function ( stageDirection ) {
            if ( (true
                && _.likeArray( stageDirection )
                && stageDirection.length === 2
                && stageDirection[ 0 ] === "mood"
                && _.isString( stageDirection[ 1 ] )
            ) ) {
                if ( mood !== null )
                    throw new Error(
                        "Found multiple mood declarations" );
                mood = stageDirection[ 1 ];
            } else {
                throw new Error(
                    "Unrecognized stage direction " +
                    JSON.stringify( stageDirection ) );
            }
        } );
        return {
            speakerId: speakerId,
            mood: mood,
            dialogue: dialogue
        };
    } );
    
    var speakerMap = {};
    _.arrEach( processedLines, function ( line ) {
        var speakerId = line.speakerId;
        speakerMap[ "|" + speakerId ] = getSpeakerInfo( speakerId );
    } );
    
    var linesCode = _.arrMap( processedLines, function ( line ) {
        var speakerId = line.speakerId;
        var mood = line.mood;
        var dialogue = line.dialogue;
        // TODO: Put speakerInfo.name in here somewhere that a screen
        // reader will read (or that a text box style could use as a
        // heading, perhaps).
        return ("" +
"    <div class=\"line\">\n" +
"        <script type=\"text/plain\">\n" +
            jsonForScriptTag( {
                speakerId: speakerId,
                mood: mood
            } ) + "\n" +
"        <" + "/script>" +
"        <canvas class=\"speaker\" width=\"1\" height=\"1\"><" +
            "/canvas>\n" +
"        <div class=\"stylish-text-wrapper\"><div><div><div\n" +
"            ><div class=\"hide-para-end\"><" + "/div\n" +
"            ><div class=\"hide-line-end\"><" + "/div\n" +
"            ><div class=\"text-to-animate\"\n" +
"                >" + htmlEscape( dialogue ) + "<" + "/div>\n" +
"        <" + "/div><" + "/div><" + "/div><" + "/div>\n" +
"    <" + "/div>"
        );
    } ).join( "\n" );
    
    return ("" +
"<div class=\"stage\">\n" +
"    <script type=\"text/plain\">\n" +
        jsonForScriptTag( {
            speakers: speakerMap
        } ) + "\n" +
"    <" + "/script>\n" +
    linesCode + "\n" +
"<" + "/div>"
    );
}

function querySelectorAllGeneration( el, generation, query ) {
    return _.arrKeep( el.querySelectorAll( query ), function ( it ) {
        var ancestor = it;
        for ( var i = 0; i < generation; i++ ) {
            if ( ancestor === null )
                return false;
            ancestor = ancestor.parentNode;
        }
        return ancestor === el;
    } );
}

function querySelectorGeneration( el, generation, query ) {
    var results = querySelectorAllGeneration( el, generation, query );
    return results.length === 0 ? null : results[ 0 ];
}

// TODO: Find a better place for this variable.
var stylishTextWrapperHeight = 75;

function activateStage( stage ) {
    var stageInfo = JSON.parse( querySelectorGeneration(
        stage, 1, "script[type=\"text/plain\"]" ).firstChild.data );
    var lines = _.arrMap(
        querySelectorAllGeneration( stage, 1, ".line" ),
        function ( line ) {
        
        return {
            lineInfo: JSON.parse( querySelectorGeneration( line, 1,
                "script[type=\"text/plain\"]" ).firstChild.data ),
            lineElement: line,
            speaker: querySelectorGeneration( line, 1, ".speaker" ),
            box: querySelectorGeneration( line, 1,
                ".stylish-text-wrapper" )
        };
    } );
    var offsetMap = _.arrMap( lines, function ( line, i ) {
        
        line.lineElement.style.pointerEvents = "none";
        setTranslation( line.box, 0, stylishTextWrapperHeight );
        
        
        var speakerId = "" + line.lineInfo.speakerId;
        var speakerInfo = stageInfo.speakers[ "|" + speakerId ];
        var mood = line.lineInfo.mood;
        if ( mood === void 0 || mood === null )
            mood = speakerInfo.defaultMood;
        function getImageMetadata() {
            var m = speakerInfo.moodImageDefaultMetadata;
            return {
                url: speakerInfo.moodImages[ mood ],
                width: m.width,
                height: m.height,
                excessScale: m.excessScale,
                flipped: speakerInfo.defaultFacing !== m.facing,
                pixelated: m.pixelated
            }
        }
        var imageMetadata = getImageMetadata();
        var facingForwards =
            speakerInfo.defaultFacing === "facingRight" ? 1 : -1;
        
        line.speaker.style.position = "absolute";
        line.speaker.style.top = "0";
        if ( 0 < facingForwards )
            line.speaker.style.left = "0";
        else
            line.speaker.style.right = "0";
        
        function getScaleFactor( imageMetadata ) {
            if ( imageMetadata.excessScale !== void 0 
                && imageMetadata.excessScale !== null )
                return 1 / imageMetadata.excessScale;
            else
                return 1;
        }
        
        function isPixelated( imageMetadata ) {
            if ( imageMetadata.pixelated !== void 0 
                && imageMetadata.pixelated !== null )
                return imageMetadata.pixelated;
            else
                return false;
        }
        
        function savingAndRestoringContext2d( ctx, body ) {
            ctx.save();
            var oldImageSmoothingEnabled = ctx.imageSmoothingEnabled;
            body();
            ctx.imageSmoothingEnabled = oldImageSmoothingEnabled;
            ctx.restore();
        }
        
        var factor = getScaleFactor( imageMetadata );
        var width = Math.floor( imageMetadata.width * factor );
        line.speaker.width = width;
        line.speaker.height =
            Math.floor( imageMetadata.height * factor );
        setTranslation( line.speaker, -width * facingForwards, 0 );
        console.log( "Loading " + imageMetadata.url );
        _.dom( "img", { src: imageMetadata.url, load: function ( e ) {
            console.log( "Loaded " + imageMetadata.url );
            console.log( imageMetadata );
            var ctx = line.speaker.getContext( "2d" );
            savingAndRestoringContext2d( ctx, function () {
                if ( imageMetadata.flipped ) {
                    ctx.translate( width, 0 );
                    ctx.scale( -1, 1 );
                }
                ctx.scale( factor, factor );
                ctx.imageSmoothingEnabled =
                    !isPixelated( imageMetadata );
                ctx.drawImage( e.target, 0, 0 );
            } );
        } } );
        
        return width * facingForwards;
    } );
    var stageState = null;
    var stageAnimation = { cancel: function () {
        // Do nothing.
    } };
    function cutToState( newStageState ) {
        if ( stageState === newStageState )
            return;
        
        if ( stageState !== null ) {
            lines[ stageState ].lineElement.style.pointerEvents =
                "none";
            setTranslation( lines[ stageState ].box,
                0, stylishTextWrapperHeight );
            setTranslation( lines[ stageState ].speaker,
                -offsetMap[ stageState ], 0 );
        }
        
        if ( newStageState !== null ) {
            lines[ newStageState ].lineElement.style.pointerEvents =
                "";
            setTranslation( lines[ newStageState ].box, 0, 0 );
            setTranslation( lines[ newStageState ].speaker, 0, 0 );
        }
        
        stageState = newStageState;
    }
    function animateToState( newStageState ) {
        if ( stageState === newStageState )
            return;
        
        function animateLine( lineBox ) {
            var hideParaEnd = querySelectorGeneration( lineBox, 4,
                "div > div > div > .hide-para-end" );
            var hideLineEnd = querySelectorGeneration( lineBox, 4,
                "div > div > div > .hide-line-end" );
            var textToAnimate = querySelectorGeneration( lineBox, 4,
                "div > div > div > .text-to-animate" );
            return animateText( {
                textToAnimateWrapper: lineBox,
                hideParaEnd: hideParaEnd,
                hideLineEnd: hideLineEnd,
                textToAnimate: textToAnimate
            }, 200 );
        }
        
        var animations = [];
        
        if ( stageState !== null ) {
            var oldI = stageState;
            lines[ oldI ].lineElement.style.pointerEvents = "none";
            animations = animations.concat( [ {
                hotspot: 100,
                play: function () {
                    return animateExitVert( 100, lines[ oldI ].box,
                        stylishTextWrapperHeight, easeOutQuad );
                }
            }, {
                hotspot: 100,
                play: function () {
                    var w = offsetMap[ oldI ];
                    return animateExitHoriz(
                        100, lines[ oldI ].speaker, w, easeOutQuad );
                }
            } ] );
        }
        
        if ( newStageState !== null ) {
            var newI = newStageState;
            lines[ newI ].lineElement.style.pointerEvents = "";
            animations = animations.concat( [ {
                hotspot: 0,
                play: function () {
                    var w = offsetMap[ newI ];
                    return animateEnterHoriz(
                        100, lines[ newI ].speaker, w, easeInQuad );
                }
            }, {
                hotspot: 0,
                play: function () {
                    return animateEnterVert( 100, lines[ newI ].box,
                        stylishTextWrapperHeight, easeInQuad );
                }
            }, {
                hotspot: 0,
                play: function () {
                    return animateLine( lines[ newI ].box );
                }
            } ] );
        }
        
        stageState = newStageState;
        
        stageAnimation.cancel();
        stageAnimation =
            combineHotspotAnimations( animations ).play();
    }
    
    cutToState( 0 );
    
    _.appendDom( stage, { click: function ( event ) {
        animateToState( stageState === null ? 0 :
            (stageState + 1) % lines.length );
    }, mousedown: function ( event ) {
        // Prevent selection of text.
        event.preventDefault();
    } } );
}


_.appendDom( window, { load: function () {
    
    var textToAnimateWrapper = document.querySelector(
        "#text-to-animate" );
    var hideParaEnd = document.querySelector(
        "#text-to-animate > div > div > div > .hide-para-end" );
    var hideLineEnd = document.querySelector(
        "#text-to-animate > div > div > div > .hide-line-end" );
    var textToAnimate = document.querySelector(
        "#text-to-animate > div > div > div > .text-to-animate" );
    
    var sampleRectangle =
        document.getElementById( "sample-rectangle" );
    var sampleRectangleCanvas =
        document.getElementById( "sample-rectangle-canvas" );
    
    function animateMainText() {
        return animateText( {
            textToAnimateWrapper: textToAnimateWrapper,
            hideParaEnd: hideParaEnd,
            hideLineEnd: hideLineEnd,
            textToAnimate: textToAnimate
        }, 100 );
    }
    
    var currentAnimation = animateMainText();
    
    var buttons = document.getElementById( "buttons" );
    function addButton( title, makeAnimation ) {
        _.appendDom( buttons, _.dom( "button", "" + title, {
            click: function () {
                currentAnimation.cancel();
                currentAnimation = makeAnimation();
            }
        } ) );
    }
    
    addButton( "Shock", function () {
        return animateShock( {
            elem: sampleRectangle
        }, 400, 100, 40 );
    } );
    
    addButton( "Flash", function () {
        return animateFlash( {
            container: sampleRectangle,
            cover: sampleRectangleCanvas
        }, 100, 0.2 );
    } );
    
    var sampleRectangleWidth =
        sampleRectangle.getBoundingClientRect().width;
    function addEnterButton( title, ease ) {
        addButton( title, function () {
            return animateEnterHorizTemp(
                400, sampleRectangle, sampleRectangleWidth, ease );
        } );
    }
    function addExitButton( title, ease ) {
        addButton( title, function () {
            return animateExitHorizTemp(
                400, sampleRectangle, sampleRectangleWidth, ease );
        } );
    }
    
    addEnterButton( "Enter quad", easeInQuad );
    addEnterButton( "Enter back", easeInBack );
    addExitButton( "Exit quad", easeInQuad );
    addExitButton( "Exit back", easeInBack );
    
    function animateEnterAndShock() {
        // NOTE: We have to put these in sequence because otherwise
        // `animateShock` might save the transformation values that
        // existed during the last moments of `animateEnter` and
        // thereby restore the wrong position when it completes.
        return animateExclusiveSequence( 200, function () {
            return animateEnterHorizTemp( 200,
                sampleRectangle, sampleRectangleWidth, easeInLinear );
        }, function () {
            return animateShock( {
                elem: sampleRectangle
            }, 400, 100, 40 );
        } );
    }
    
    addButton( "Enter and shock", function () {
        return animateEnterAndShock();
    } );
    
    addButton( "Animate text", function () {
        return animateMainText();
    } );
    
    addButton( "Everything", function () {
        return combineHotspotAnimations( [ {
            hotspot: 200,
            play: function () {
                return animateEnterAndShock();
            }
        }, {
            hotspot: 50,
            play: function () {
                return animateFlash( {
                    container: sampleRectangle,
                    cover: sampleRectangleCanvas
                }, 100, 0.2 );
            }
        }, {
            hotspot: 0,
            play: function () {
                return animateMainText();
            }
        } ] ).play();
    } );
    
    
    var stage = _.el( "stage1" );
    activateStage( stage );
    var stage2Wrapper = _.el( "stage2Wrapper" );
    stage2Wrapper.innerHTML = compileConversation( [
        [ "elisa1", "This example was generated from JSON-like data for ease of development. The other one was initialized from the static HTML document structure." ],
        [ "elisa2", "The dialogue was part of the static HTML? What's the point of that?" ],
        [ "elisa1", "Better visibility to search engines, potentially. It might even be easier to get it to render in static form for offline printing or accessibility." ],
        [ "elisa2", "Ah, wow. I see, hm... Never mind, I think I forgot everything you just said. Run that by me again?" ]
    ], function ( speakerId ) {
        return {
            elisa1: {
                name: "Elisa",
                defaultFacing: "facingRight",
                defaultMood: "businesslike",
                moodImages: {
                    businesslike: "lib/elisa-standalone.png"
                },
                moodImageDefaultMetadata: {
                    facing: "facingRight",
                    width: 34,
                    height: 41,
                    excessScale: 0.14,
                    pixelated: true
                }
            },
            elisa2: {
                name: "Elisa",
                defaultFacing: "facingLeft",
                defaultMood: "businesslike",
                moodImages: {
                    businesslike: "lib/elisa-standalone.png"
                },
                moodImageDefaultMetadata: {
                    facing: "facingRight",
                    width: 34,
                    height: 41,
                    excessScale: 0.14,
                    pixelated: true
                }
            }
        }[ speakerId ];
    } );
    activateStage(
        querySelectorGeneration( stage2Wrapper, 1, ".stage" ) );
} } );

})();

</script>
</head>
<body>

<h1>Rinksprite animated text demo</h1>

<p>This is part of <a href="https://github.com/rocketnia/rinksprite">the Rinksprite project on GitHub</a>, a small collection of experiments in HTML-based animation.</p>

<p>Many text animation libraries out there modify the DOM to separate text into its individual characters. This demo instead emulates its typewriter effect by rendering white rectangles over the top of the text.</p>

<p>The artwork is by Jo Seraph and Jetrel. For more information, see the credits and links at the bottom of the page.</p>

<div id="stage1" class="stage">
    <script type="text/plain"> {
        "speakers": {
            "|witch": {
                "name": "Witch",
                "defaultFacing": "facingRight",
                "defaultMood": "guffawing",
                "moodImages": {
                    "pensive": "lib/witch/Witch_01.png",
                    "businesslike": "lib/witch/Witch_02.png",
                    "nervous": "lib/witch/Witch_03.png",
                    "urging": "lib/witch/Witch_04.png",
                    "despondent": "lib/witch/Witch_05.png",
                    "guffawing": "lib/witch/Witch_06.png",
                    "pleased": "lib/witch/Witch_07.png",
                    "aggrieved": "lib/witch/Witch_08.png"
                },
                "moodImageDefaultMetadata": {
                    "facing": "facingLeft",
                    "width": 229,
                    "height": 351,
                    "excessScale": 1.3
                }
            },
            "|innkeeper": {
                "name": "Innkeeper",
                "defaultFacing": "facingLeft",
                "defaultMood": "pleased",
                "moodImages": {
                    "businesslike": "lib/innkeeper/Innkeeper_01.png",
                    "pleased": "lib/innkeeper/Innkeeper_02.png",
                    "flummoxed": "lib/innkeeper/Innkeeper_03.png",
                    "despondent": "lib/innkeeper/Innkeeper_04.png",
                    "aggrieved": "lib/innkeeper/Innkeeper_05.png",
                    "urging": "lib/innkeeper/Innkeeper_06.png",
                    "effervescent": "lib/innkeeper/Innkeeper_07.png",
                    "nervous": "lib/innkeeper/Innkeeper_08.png"
                },
                "moodImageDefaultMetadata": {
                    "facing": "facingLeft",
                    "width": 241,
                    "height": 346,
                    "excessScale": 1.3
                }
            }
        }
    } </script>
    <div class="line">
        <script type="text/plain"> {
            "speakerId": "witch"
        } </script>
        <canvas class="speaker" width="1" height="1"></canvas>
        <div class="stylish-text-wrapper"><div><div><div
            ><div class="hide-para-end"></div
            ><div class="hide-line-end"></div
            ><div class="text-to-animate"
                >
                This is some dialogue. Click anywhere on the text box
                or the stage area to advance. Anyway, this is line
                one. This is line one. This is line one. This is line
                one. This is line one. This is line one.</div>
<!--
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l l l l l l l l l l l l l l l l l l l l l l l l l
                l l l</div>
-->
        </div></div></div></div>
    </div>
    <div class="line">
        <script type="text/plain"> {
            "speakerId": "innkeeper"
        } </script>
        <canvas class="speaker" width="1" height="1"></canvas>
        <div class="stylish-text-wrapper"><div><div><div
            ><div class="hide-para-end"></div
            ><div class="hide-line-end"></div
            ><div class="text-to-animate"
                >This is line two. This is line two. This is line two.
                This is line two. This is line two. This is line two.
                This is line two. This is line two. This is line two.
                This is line two. This is line two. This is line
                two.</div>
        </div></div></div></div>
    </div>
    <div class="line">
        <script type="text/plain"> {
            "speakerId": "witch",
            "mood": "aggrieved"
        } </script>
        <canvas class="speaker" width="1" height="1"></canvas>
        <div class="stylish-text-wrapper"><div><div><div
            ><div class="hide-para-end"></div
            ><div class="hide-line-end"></div
            ><div class="text-to-animate"
                >This is line three. This is line three. This is line
                three. This is line three. This is line three. This is
                line three. This is line three. This is line three.
                This is line three. This is line three.</div>
        </div></div></div></div>
    </div>
    <div class="line">
        <script type="text/plain"> {
            "speakerId": "innkeeper",
            "mood": "flummoxed"
        } </script>
        <canvas class="speaker" width="1" height="1"></canvas>
        <div class="stylish-text-wrapper"><div><div><div
            ><div class="hide-para-end"></div
            ><div class="hide-line-end"></div
            ><div class="text-to-animate"
                >This is line four. This is line four. This is line
                four. This is line four. This is line four. This is
                line four. This is line four. This is line four.
                Anyway, now we'll continue from the beginning of the
                dialogue.</div>
        </div></div></div></div>
    </div>
</div>

<div id="stage2Wrapper"></div>

<div id="debug-area">
    <!-- (204 by 246) = (34 by 41) * 6 -->
    <div id="sample-rectangle"
        ><canvas id="sample-rectangle-canvas" width="1" height="1"
            ></canvas
        ><img src="lib/elisa-standalone.png" width="204" height="246"
            /></div>
    <div id="text-to-animate" class="stylish-text-wrapper"><div><div><div
        ><div class="hide-para-end"></div
        ><div class="hide-line-end"></div
        ><div class="text-to-animate"
            >This is some animating text. This is some animating text.
            This is some animating text. This is some animating text. This
            is some animating text. This is some animating text. This is
            some animating text. This is some animating text.</div>
    </div></div></div></div>
    <div id="buttons"></div>
</div>

<p
    >The witch portrait sprites were created by Jo Seraph and released
    under the CC-BY 3.0 license. They're
    <a href="https://opengameart.org/content/js-actor-witch"
        >available at Open Game Art</a>.</p>
<p
    >The innkeeper portrait sprites were created by Jo Seraph and
    released under the CC-BY 3.0 license. They're
    <a href="https://opengameart.org/content/js-actor-innkeeper"
        >available at Open Game Art</a>.</p>
<p
    >The Elisa platform game character sprites were created by Jetrel
    and placed into the public domain under the CC0 license. They're
    <a href="https://opengameart.org/content/castle-platformer"
        >available at Open Game Art</a>.</p>
</body>
</html>
